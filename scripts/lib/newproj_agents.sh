#!/usr/bin/env bash
# ============================================================
# ACFS newproj TUI Wizard - AGENTS.md Generator
# Generates tech-stack-aware AGENTS.md files for new projects
# ============================================================

# Prevent multiple sourcing
if [[ -n "${_ACFS_NEWPROJ_AGENTS_SH_LOADED:-}" ]]; then
    return 0
fi
_ACFS_NEWPROJ_AGENTS_SH_LOADED=1

# ============================================================
# Section Registry
# ============================================================

# All available section IDs in order
declare -ga AGENTS_SECTION_ORDER=(
    "header"
    "rule_1_absolute"
    "irreversible_actions"
    "nodejs_toolchain"
    "python_toolchain"
    "rust_toolchain"
    "go_toolchain"
    "ruby_toolchain"
    "java_toolchain"
    "php_toolchain"
    "elixir_toolchain"
    "docker_workflow"
    "code_editing"
    "console_output"
    "landing_the_plane"
    "issue_tracking"
)

# Section metadata: section_id -> "title|required|depends_on"
declare -gA AGENTS_SECTION_META=(
    ["header"]="Header|true|"
    ["rule_1_absolute"]="RULE 1 – ABSOLUTE|true|"
    ["irreversible_actions"]="IRREVERSIBLE GIT & FILESYSTEM ACTIONS|true|"
    ["nodejs_toolchain"]="Node / JS Toolchain|false|"
    ["python_toolchain"]="Python Toolchain|false|"
    ["rust_toolchain"]="Rust Toolchain|false|"
    ["go_toolchain"]="Go Toolchain|false|"
    ["ruby_toolchain"]="Ruby Toolchain|false|"
    ["java_toolchain"]="Java Toolchain|false|"
    ["php_toolchain"]="PHP Toolchain|false|"
    ["elixir_toolchain"]="Elixir Toolchain|false|"
    ["docker_workflow"]="Docker Workflow|false|"
    ["code_editing"]="Code Editing Discipline|true|"
    ["console_output"]="Console Output|false|"
    ["landing_the_plane"]="Landing the Plane|true|"
    ["issue_tracking"]="Issue Tracking with br|false|"
)

# ============================================================
# Section Content Templates
# ============================================================

# Get section content by ID
# Usage: content=$(get_section_content "section_id" "project_name")
get_section_content() {
    local section_id="$1"
    local project_name="${2:-my-project}"

    case "$section_id" in
        header)
            _section_header "$project_name"
            ;;
        rule_1_absolute)
            _section_rule_1
            ;;
        irreversible_actions)
            _section_irreversible
            ;;
        nodejs_toolchain)
            _section_nodejs
            ;;
        python_toolchain)
            _section_python
            ;;
        rust_toolchain)
            _section_rust
            ;;
        go_toolchain)
            _section_go
            ;;
        ruby_toolchain)
            _section_ruby
            ;;
        java_toolchain)
            _section_java
            ;;
        php_toolchain)
            _section_php
            ;;
        elixir_toolchain)
            _section_elixir
            ;;
        docker_workflow)
            _section_docker
            ;;
        code_editing)
            _section_code_editing
            ;;
        console_output)
            _section_console_output
            ;;
        landing_the_plane)
            _section_landing
            ;;
        issue_tracking)
            _section_issue_tracking
            ;;
        *)
            echo ""
            ;;
    esac
}

# ============================================================
# Core Required Sections
# ============================================================

_section_header() {
    local project_name="$1"
    cat << EOF
# AGENTS.md — $project_name

This document contains instructions and context for AI coding agents working on this project.

Generated by \`acfs newproj --interactive\` on ${AGENTS_GENERATED_AT:-unknown}.
Detected tech stack: ${AGENTS_TECH_STACK_LIST:-none}
Tech-dependent sections include toolchain and Docker workflow blocks.

To regenerate with different options, move AGENTS.md aside and re-run:
  acfs newproj --interactive

---
EOF
}

_section_rule_1() {
    cat << 'EOF'

## RULE 1 – ABSOLUTE (DO NOT EVER VIOLATE THIS)

You may NOT delete any file or directory unless I explicitly give the exact command **in this session**.

- This includes files you just created (tests, tmp files, scripts, etc.).
- You do not get to decide that something is "safe" to remove.
- If you think something should be removed, stop and ask. You must receive clear written approval **before** any deletion command is even proposed.

Treat "never delete files without permission" as a hard invariant.

---
EOF
}

_section_irreversible() {
    cat << 'EOF'

## IRREVERSIBLE GIT & FILESYSTEM ACTIONS

Absolutely forbidden unless I give the **exact command and explicit approval** in the same message:

- `git reset --hard`
- `git clean -fd`
- `rm -rf`
- Any command that can delete or overwrite code/data

Rules:

1. If you are not 100% sure what a command will delete, do not propose or run it. Ask first.
2. Prefer safe tools: `git status`, `git diff`, `git stash`, copying to backups, etc.
3. After approval, restate the command verbatim, list what it will affect, and wait for confirmation.
4. When a destructive command is run, record in your response:
   - The exact user text authorizing it
   - The command run
   - When you ran it

If that audit trail is missing, then you must act as if the operation never happened.

---
EOF
}

_section_code_editing() {
    cat << 'EOF'

## Code Editing Discipline

- Do **not** run scripts that bulk-modify code (codemods, invented one-off scripts, giant `sed`/regex refactors).
- Large mechanical changes: break into smaller, explicit edits and review diffs.
- Subtle/complex changes: edit by hand, file-by-file, with careful reasoning.

---
EOF
}

_section_landing() {
    cat << 'EOF'

## Landing the Plane (Session Completion)

**When ending a work session**, complete ALL steps below. Work is NOT complete until changes are pushed.

**MANDATORY WORKFLOW:**

1. **Check status** - Review what changed with `git status` and `git diff`
2. **Run quality gates** (if code changed) - Tests, linters, builds
3. **Stage changes** - `git add <files>`
4. **Commit** - `git commit -m "descriptive message"`
5. **Push** - `git push`
6. **Verify** - `git status` should show "up to date with origin"

**CRITICAL RULES:**
- Work is NOT complete until `git push` succeeds
- NEVER stop before pushing - that leaves work stranded locally
- If push fails, resolve and retry until it succeeds

---
EOF
}

# ============================================================
# Language/Runtime Toolchain Sections
# ============================================================

_section_nodejs() {
    cat << 'EOF'

## Node / JS Toolchain

- Use **bun** for package management and running scripts.
- Lockfiles: only `bun.lock`. Do not introduce other lockfiles.
- Target latest Node.js LTS. No need to support old Node versions.

Commands:
```bash
bun install          # Install dependencies
bun run dev          # Development server
bun run build        # Production build
bun run test         # Run tests
bun run lint         # Lint check
```

---
EOF
}

_section_python() {
    cat << 'EOF'

## Python Toolchain

- Use **uv** for Python package management.
- Project config lives in `pyproject.toml`.
- Virtual environments are managed automatically by uv.

Commands:
```bash
uv sync              # Install dependencies
uv run python        # Run Python in venv
uv run pytest        # Run tests
uv run ruff check    # Lint check
uv run ruff format   # Format code
```

---
EOF
}

_section_rust() {
    cat << 'EOF'

## Rust Toolchain

- Use **cargo** for all Rust operations.
- Format code with `cargo fmt` before committing.
- Run `cargo clippy` to catch common issues.

Commands:
```bash
cargo build          # Debug build
cargo build --release # Release build
cargo test           # Run tests
cargo fmt            # Format code
cargo clippy         # Lint check
```

---
EOF
}

_section_go() {
    cat << 'EOF'

## Go Toolchain

- Use Go modules (`go.mod`) for dependency management.
- Format code with `gofmt` or `goimports` before committing.
- Run `go vet` and `staticcheck` for linting.

Commands:
```bash
go build ./...       # Build all packages
go test ./...        # Run all tests
go fmt ./...         # Format code
go vet ./...         # Static analysis
```

---
EOF
}

_section_ruby() {
    cat << 'EOF'

## Ruby Toolchain

- Use **Bundler** for dependency management.
- Project config in `Gemfile`.
- Use RuboCop for linting and formatting.

Commands:
```bash
bundle install       # Install dependencies
bundle exec rails s  # Start server (Rails)
bundle exec rspec    # Run tests
bundle exec rubocop  # Lint check
```

---
EOF
}

_section_java() {
    cat << 'EOF'

## Java Toolchain

- Use **Maven** (`pom.xml`) or **Gradle** (`build.gradle`) for builds.
- Target latest LTS Java version unless otherwise specified.

Maven commands:
```bash
mvn compile          # Compile
mvn test             # Run tests
mvn package          # Build JAR
mvn clean install    # Full clean build
```

Gradle commands:
```bash
./gradlew build      # Build
./gradlew test       # Run tests
./gradlew clean      # Clean
```

---
EOF
}

_section_php() {
    cat << 'EOF'

## PHP Toolchain

- Use **Composer** for dependency management.
- Project config in `composer.json`.
- Use PHP-CS-Fixer or PHPStan for code quality.

Commands:
```bash
composer install     # Install dependencies
composer update      # Update dependencies
php artisan serve    # Start server (Laravel)
./vendor/bin/phpunit # Run tests
```

---
EOF
}

_section_elixir() {
    cat << 'EOF'

## Elixir Toolchain

- Use **Mix** for project management.
- Project config in `mix.exs`.
- Use Credo for static analysis.

Commands:
```bash
mix deps.get         # Install dependencies
mix compile          # Compile
mix test             # Run tests
mix format           # Format code
mix credo            # Static analysis
```

---
EOF
}

# ============================================================
# Infrastructure/Build Tool Sections
# ============================================================

_section_docker() {
    cat << 'EOF'

## Docker Workflow

- Use Docker for containerized development and deployment.
- `Dockerfile` for single container builds.
- `docker-compose.yml` for multi-container setups.

Commands:
```bash
docker build -t app .                    # Build image
docker run -p 3000:3000 app              # Run container
docker-compose up -d                     # Start services
docker-compose down                      # Stop services
docker-compose logs -f                   # View logs
```

Best practices:
- Use multi-stage builds to minimize image size.
- Pin base image versions (e.g., `node:22-alpine`).
- Don't store secrets in images; use environment variables.

---
EOF
}

_section_console_output() {
    cat << 'EOF'

## Console Output

Use colored output for clarity in scripts:

```bash
echo -e "\033[34m[1/5] Step description\033[0m"     # Blue progress
echo -e "\033[90m    Details...\033[0m"             # Gray details
echo -e "\033[33mWarning message\033[0m"            # Yellow warnings
echo -e "\033[31mError message\033[0m"              # Red errors
echo -e "\033[32mSuccess message\033[0m"            # Green success
```

Rules:
- Progress/status goes to `stderr` (stdout remains clean for piping)
- Errors should always be visible regardless of verbosity settings

---
EOF
}

_section_issue_tracking() {
    cat << 'EOF'

## Issue Tracking with br (Beads)

All issue tracking goes through **Beads**. No other TODO systems.

**Note:** `br` is a convenience alias (installed by `acfs/zsh/acfs.zshrc`) for the real Beads CLI: `bd`.
If `br` is unavailable (CI / non-interactive shells), use `bd` directly.

Key invariants:
- `.beads/` is authoritative state and **must always be committed** with code changes.
- Do not edit `.beads/*.jsonl` directly; only via `br` / `bd`.

### Basics

Check ready work:
```bash
br ready
```

Create issues:
```bash
br create "Issue title" -t bug|feature|task -p 0-4
```

Update:
```bash
br update <id> --status in_progress
```

Complete:
```bash
br close <id> --reason "Completed"
```

Types: `bug`, `feature`, `task`, `epic`, `chore`

Priorities:
- `0` critical (security, data loss, broken builds)
- `1` high
- `2` medium (default)
- `3` low
- `4` backlog

Agent workflow:
1. `br ready` to find unblocked work.
2. Claim: `br update <id> --status in_progress`.
3. Implement + test.
4. Close when done.
5. Commit `.beads/` in the same commit as code changes.

---
EOF
}

# ============================================================
# Section Helper Functions
# ============================================================

# Check if a section is required
# Usage: is_section_required "section_id"
is_section_required() {
    local section_id="$1"
    local meta="${AGENTS_SECTION_META[$section_id]:-}"

    if [[ -z "$meta" ]]; then
        return 1
    fi

    local required
    required=$(echo "$meta" | cut -d'|' -f2)
    [[ "$required" == "true" ]]
}

# Get section title
# Usage: title=$(get_section_title "section_id")
get_section_title() {
    local section_id="$1"
    local meta="${AGENTS_SECTION_META[$section_id]:-}"

    if [[ -z "$meta" ]]; then
        echo ""
        return
    fi

    echo "$meta" | cut -d'|' -f1
}

# Get all required sections
# Usage: required_sections=$(get_required_sections)
get_required_sections() {
    local sections=()
    for section_id in "${AGENTS_SECTION_ORDER[@]}"; do
        if is_section_required "$section_id"; then
            sections+=("$section_id")
        fi
    done
    echo "${sections[*]}"
}

# Get sections for a given tech stack
# Usage: sections=$(get_sections_for_tech_stack nodejs typescript docker)
get_sections_for_tech_stack() {
    local tech_stack=("$@")
    local sections=()
    local seen=()

    # Start with required sections
    for section_id in "${AGENTS_SECTION_ORDER[@]}"; do
        if is_section_required "$section_id"; then
            sections+=("$section_id")
            seen+=("$section_id")
        fi
    done

    # Add tech-specific sections
    for tech in "${tech_stack[@]}"; do
        local section_id=""
        case "$tech" in
            nodejs|typescript|nextjs|nuxt|svelte|astro|remix|vite)
                section_id="nodejs_toolchain"
                ;;
            python|python-legacy)
                section_id="python_toolchain"
                ;;
            rust)
                section_id="rust_toolchain"
                ;;
            go)
                section_id="go_toolchain"
                ;;
            ruby)
                section_id="ruby_toolchain"
                ;;
            java|java-maven|java-gradle)
                section_id="java_toolchain"
                ;;
            php)
                section_id="php_toolchain"
                ;;
            elixir)
                section_id="elixir_toolchain"
                ;;
            docker|docker-compose)
                section_id="docker_workflow"
                ;;
        esac

        # Add if not already seen
        if [[ -n "$section_id" ]] && [[ ! " ${seen[*]} " =~ " ${section_id} " ]]; then
            sections+=("$section_id")
            seen+=("$section_id")
        fi
    done

    echo "${sections[*]}"
}

# ============================================================
# Generator Functions
# ============================================================

# Generate AGENTS.md content
# Usage: content=$(generate_agents_md "project_name" [tech_stack...])
# Options via environment:
#   AGENTS_ENABLE_BD=true|false - Include bd issue tracking section
#   AGENTS_ENABLE_CONSOLE=true|false - Include console output section
generate_agents_md() {
    local project_name="${1:-my-project}"
    shift
    local tech_stack=("$@")

    local enable_bd="${AGENTS_ENABLE_BD:-false}"
    local enable_console="${AGENTS_ENABLE_CONSOLE:-false}"
    local generated_at
    local tech_stack_list="none"

    log_info "Generating AGENTS.md for: $project_name" 2>/dev/null || true
    log_debug "Tech stack: ${tech_stack[*]}" 2>/dev/null || true

    generated_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    if [[ ${#tech_stack[@]} -gt 0 ]]; then
        tech_stack_list=$(printf "%s, " "${tech_stack[@]}")
        tech_stack_list="${tech_stack_list%, }"
    fi

    AGENTS_GENERATED_AT="$generated_at"
    AGENTS_TECH_STACK_LIST="$tech_stack_list"

    # Get sections to include
    local sections
    sections=$(get_sections_for_tech_stack "${tech_stack[@]}")
    read -ra section_array <<< "$sections"

    # Add optional sections based on flags
    if [[ "$enable_bd" == "true" ]]; then
        section_array+=("issue_tracking")
    fi
    if [[ "$enable_console" == "true" ]]; then
        section_array+=("console_output")
    fi

    # Sort sections according to order
    local ordered_sections=()
    for ordered_id in "${AGENTS_SECTION_ORDER[@]}"; do
        for section_id in "${section_array[@]}"; do
            if [[ "$ordered_id" == "$section_id" ]]; then
                ordered_sections+=("$section_id")
                break
            fi
        done
    done

    log_debug "Sections to include: ${ordered_sections[*]}" 2>/dev/null || true

    # Generate content
    local content=""
    for section_id in "${ordered_sections[@]}"; do
        local section_content
        section_content=$(get_section_content "$section_id" "$project_name")
        content+="$section_content"
    done

    printf '%s\n' "$content"
}

# Generate AGENTS.md and write to file
# Usage: generate_agents_md_file "/path/to/project" "project_name" [tech_stack...]
generate_agents_md_file() {
    local project_dir="$1"
    local project_name="$2"
    shift 2
    local tech_stack=("$@")

    local agents_file="$project_dir/AGENTS.md"

    log_info "Writing AGENTS.md to: $agents_file" 2>/dev/null || true

    local content
    content=$(generate_agents_md "$project_name" "${tech_stack[@]}")

    if [[ -z "$content" ]]; then
        log_error "Failed to generate AGENTS.md content" 2>/dev/null || true
        return 1
    fi

    echo "$content" > "$agents_file"

    if [[ ! -f "$agents_file" ]]; then
        log_error "Failed to write AGENTS.md" 2>/dev/null || true
        return 1
    fi

    log_info "AGENTS.md created successfully" 2>/dev/null || true
    return 0
}

# ============================================================
# Validation Functions
# ============================================================

# Validate AGENTS.md content
# Usage: validate_agents_md "content"
# Returns: 0 if valid, 1 if invalid (with error messages on stdout)
validate_agents_md() {
    local content="$1"
    local errors=()

    # Check for required sections
    if [[ ! "$content" =~ "# AGENTS.md" ]]; then
        errors+=("Missing header: # AGENTS.md")
    fi

    if [[ ! "$content" =~ "RULE 1" ]]; then
        errors+=("Missing required section: RULE 1 – ABSOLUTE")
    fi

    if [[ ! "$content" =~ "IRREVERSIBLE" ]]; then
        errors+=("Missing required section: IRREVERSIBLE GIT & FILESYSTEM ACTIONS")
    fi

    if [[ ! "$content" =~ "Code Editing" ]]; then
        errors+=("Missing required section: Code Editing Discipline")
    fi

    if [[ ! "$content" =~ "Landing the Plane" ]]; then
        errors+=("Missing required section: Landing the Plane")
    fi

    # Check for minimum content length (at least 1000 chars for basic structure)
    if [[ ${#content} -lt 1000 ]]; then
        errors+=("Content too short: ${#content} chars (minimum 1000)")
    fi

    # Check for balanced markdown headers
    local h2_count
    h2_count=$(echo "$content" | grep -c "^## " || true)
    if [[ "$h2_count" -lt 3 ]]; then
        errors+=("Too few H2 sections: $h2_count (minimum 3)")
    fi

    # Check for horizontal rules as separators
    local hr_count
    hr_count=$(echo "$content" | grep -c "^---$" || true)
    if [[ "$hr_count" -lt 2 ]]; then
        errors+=("Too few section separators: $hr_count (minimum 2)")
    fi

    # Report errors
    if [[ ${#errors[@]} -gt 0 ]]; then
        for error in "${errors[@]}"; do
            echo "ERROR: $error"
        done
        return 1
    fi

    return 0
}

# Validate AGENTS.md file
# Usage: validate_agents_md_file "/path/to/AGENTS.md"
validate_agents_md_file() {
    local agents_file="$1"

    if [[ ! -f "$agents_file" ]]; then
        echo "ERROR: File not found: $agents_file"
        return 1
    fi

    if [[ ! -r "$agents_file" ]]; then
        echo "ERROR: Cannot read file: $agents_file"
        return 1
    fi

    local content
    content=$(cat "$agents_file")

    validate_agents_md "$content"
}

# ============================================================
# Section Customization
# ============================================================

# Add a custom section to the registry
# Usage: register_custom_section "section_id" "title" "content_function"
register_custom_section() {
    local section_id="$1"
    local title="$2"
    local content_fn="$3"

    AGENTS_SECTION_META["$section_id"]="$title|false|"
    AGENTS_SECTION_ORDER+=("$section_id")

    # Store function name for later invocation
    eval "_custom_section_${section_id}() { $content_fn; }"
}

# Get list of available sections
# Usage: list_available_sections
list_available_sections() {
    for section_id in "${AGENTS_SECTION_ORDER[@]}"; do
        local title
        title=$(get_section_title "$section_id")
        local required="optional"
        is_section_required "$section_id" && required="required"
        echo "$section_id: $title ($required)"
    done
}

# ============================================================
# Template Preview
# ============================================================

# Preview what sections would be included
# Usage: preview_agents_md "project_name" [tech_stack...]
preview_agents_md() {
    local project_name="${1:-my-project}"
    shift
    local tech_stack=("$@")

    echo "AGENTS.md Preview for: $project_name"
    echo "Tech stack: ${tech_stack[*]:-none}"
    echo ""
    echo "Sections to include:"

    local sections
    sections=$(get_sections_for_tech_stack "${tech_stack[@]}")
    read -ra section_array <<< "$sections"

    local enable_bd="${AGENTS_ENABLE_BD:-false}"
    local enable_console="${AGENTS_ENABLE_CONSOLE:-false}"

    if [[ "$enable_bd" == "true" ]]; then
        section_array+=("issue_tracking")
    fi
    if [[ "$enable_console" == "true" ]]; then
        section_array+=("console_output")
    fi

    for section_id in "${AGENTS_SECTION_ORDER[@]}"; do
        for included in "${section_array[@]}"; do
            if [[ "$section_id" == "$included" ]]; then
                local title
                title=$(get_section_title "$section_id")
                local required=""
                is_section_required "$section_id" && required=" [required]"
                echo "  - $title$required"
                break
            fi
        done
    done
}
